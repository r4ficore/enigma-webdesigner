<!DOCTYPE html>
<html lang="pl" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Enigma E‚ÄëBook Builder</title>

  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
        crossorigin="anonymous" referrerpolicy="no-referrer" />

  <style>
    /* === STYL JAK W ENIGMA VISUAL (1:1) === */
    html { background-color: #000; }
    body {
      font-family: 'Inter', sans-serif;
      background-color: #000000; color: #f6f6f6;
      display: flex; justify-content: center; align-items: center;
      height: 100vh; margin: 0;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    .chat-container { width: 100%; max-width: 800px; height: 100%;
      background: #000000; border-radius: 8px; display: flex; flex-direction: column;
      overflow: hidden; position: relative; }
    .chat-header {
      background: linear-gradient(180deg, #2e2e2e 20%, #0f0f0f 80%);
      color: #f6f6f6; padding: 15px 24px; flex-shrink: 0; display: flex;
      justify-content: space-between; align-items: center; border-bottom: none;
    }
    .header-info h2 { font-size: 0.9em; font-weight: 500; }
    .header-menu { position: relative; }
    .header-menu i { color: #6B7280; cursor: pointer; }
    .menu-dropdown {
      display: none; position: absolute; right: 0; top: 30px; background-color: #1f1f22;
      border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; overflow: hidden; z-index: 10; width: 150px;
    }
    .menu-dropdown a {
      color: #f6f6f6; padding: 10px 15px; text-decoration: none; display: block; font-size: 14px;
    }
    .menu-dropdown a:hover { background-color: #2a2a2e; }

    .chat-messages {
      flex: 1; padding: 24px; overflow-y: auto; display: flex; flex-direction: column; gap: 24px; margin-top: 10px;
    }
    .message {
      max-width: 85%; padding: 14px 20px; border-radius: 16px; word-wrap: break-word; line-height: 1.55;
      box-sizing: border-box; font-size: 14px;
      background: linear-gradient(180deg, rgba(34,34,34,0.9), rgba(22,22,22,0.9));
      border: 1px solid rgba(255,255,255,0.08);
    }
    .user-message { align-self: flex-end; margin-left: auto; color: #f6f6f6; }
    .bot-message  { align-self: flex-start; margin-right: auto; }
    .bot-message strong { display:block; font-weight:600; color:#d1d5db; margin-bottom:8px; }

    .chat-input-container { padding: 16px 16px 14px 14px; flex-shrink: 0; }
    .chat-input-wrapper { position: relative; }
    #user-input {
      width: 100%; min-height: 48px; max-height: 200px; padding: 13px 80px 13px 24px;
      background-color: transparent; border: 1px solid rgba(255,255,255,0.15); border-radius: 14px;
      color:#f6f6f6; outline: none; resize: none; font-family: inherit; font-size: 14px; line-height: 1.5;
      transition: border-color 0.2s ease; box-sizing: border-box;
    }
    #user-input:focus { border-color: #d6b376; }
    #send-btn {
      position: absolute; right: 18px; top: 50%; transform: translateY(-50%);
      background: none; color: #f6f6f6; border: none; width: 32px; height: 32px; border-radius: 50%;
      cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;
      transition: background-color 0.2s ease;
    }
    #send-btn:hover:not(:disabled) { background: #d6b376; color:#101010; }
    #send-btn:disabled { background: none; color: #6B7280; cursor: not-allowed; }

    .typing-indicator { align-self: flex-start; max-width: 85%; }
    .typing-dot { width: 8px; height: 8px; background-color: #d6b376; border-radius: 50%;
      animation: typing-animation 1.4s infinite ease-in-out; }
    @keyframes typing-animation {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.6; }
      30% { transform: translateY(-6px); opacity: 1; }
    }
    .typing-indicator-dots {
      display: flex; gap: 6px; padding: 18px 20px;
      background: linear-gradient(180deg, rgba(34,34,34,0.9), rgba(22,22,22,0.9));
      border: 1px solid rgba(255,255,255,0.08); border-radius: 16px;
    }

    /* Pasek akcji pod odpowiedziƒÖ (Akceptuj / Popraw / Dalej / Scal) */
    .action-bar {
      display: flex; gap: 8px; margin-top: 10px;
    }
    .action-btn {
      background: #1f1f22; border: 1px solid rgba(255,255,255,0.12);
      color: #f6f6f6; padding: 6px 10px; border-radius: 10px; font-size: 12px; cursor: pointer;
    }
    .action-btn:hover { background:#2a2a2e; }
    .action-btn.primary { background:#d6b376; color:#101010; border-color:#d6b376; }
    .action-btn.danger  { border-color:#e26a6a; color:#ffdede; }

    /* === PODGLƒÑD PLIK√ìW TXT W BƒÑBLU CZATU === */
    .file-block { margin-top:10px; border:1px solid rgba(255,255,255,.08); border-radius:12px; background:#141414; }
    .file-block-header { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; gap:8px; }
    .file-name { font-size:12px; color:#d1d5db; font-weight:600; display:flex; align-items:center; gap:6px; }
    .file-actions { display:flex; gap:6px; }
    .file-actions button,
    .file-actions a { background:#1f1f22; border:1px solid rgba(255,255,255,.12); color:#f6f6f6; font-size:11px; padding:5px 8px; border-radius:8px; text-decoration:none; cursor:pointer; }
    .file-actions .primary { background:#d6b376; color:#101010; border-color:#d6b376; }
    .file-preview { display:none; border-top:1px solid rgba(255,255,255,.08); }
    .file-preview-body {
      font-family: "Roboto Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap; padding:12px; font-size:12.5px; line-height:1.55; color:#e5e7eb;
      max-height:320px; overflow:auto;
    }

    /* Modal historii */
    .history-modal { display:none; position:absolute; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.8); z-index:20; justify-content:center; align-items:center; }
    .history-content { background-color:#121212; padding:24px; border-radius:12px; width:80%; max-width:500px; max-height:80vh; display:flex; flex-direction:column; }
    .history-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
    .history-header h3 { margin:0; font-size:1.2em; }
    #close-history { background:none; border:none; color:#f6f6f6; font-size:24px; cursor:pointer; }
    #history-list { list-style:none; padding:0; margin:0; overflow-y:auto; }
    #history-list li { padding:12px 15px; border-bottom:1px solid rgba(255,255,255,0.1); cursor:pointer; font-size:14px; transition:background-color .2s ease; }
    #history-list li:hover { background-color:#2a2a2e; }
    #history-list li:last-child { border-bottom:none; }

    /* Link do pobrania finalnego ebooka */
    .final-download {
      background: linear-gradient(180deg, rgba(34,34,34,0.9), rgba(22,22,22,0.9));
      border: 1px solid rgba(255,255,255,0.08); border-radius: 12px;
      padding: 16px; margin-top: 10px; text-align: center;
    }
    .final-download a {
      background: #d6b376; color: #101010; padding: 10px 20px;
      border-radius: 8px; text-decoration: none; font-weight: 600;
      display: inline-block; transition: background-color 0.2s ease;
    }
    .final-download a:hover { background: #e5c58c; }

    /* Panel zarzƒÖdzania zaakceptowanymi rozdzia≈Çami */
    .chapter-management {
      display: none;
      padding: 16px 24px 0 24px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(12,12,12,0.85);
    }
    .chapter-management.has-items { display: block; }
    .chapter-management-header {
      display: flex; justify-content: space-between; align-items: baseline;
      gap: 12px; margin-bottom: 8px;
    }
    .chapter-management-header h3 {
      margin: 0; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.08em;
      color: #d6b376;
    }
    .chapter-management-header span {
      font-size: 0.7rem; color: #9ca3af;
    }
    #accepted-chapters-list {
      list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 10px;
    }
    .accepted-chapter-item {
      display: flex; justify-content: space-between; align-items: center;
      gap: 12px; padding: 10px 12px; border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px; background: rgba(24,24,24,0.85);
    }
    .accepted-chapter-label {
      font-size: 0.78rem; font-weight: 500; color: #f3f4f6;
    }
    .accepted-chapter-actions { display: flex; gap: 6px; flex-shrink: 0; }
    .accepted-chapter-actions button {
      background: #1f1f22; border: 1px solid rgba(255,255,255,0.12);
      color: #f6f6f6; padding: 4px 8px; border-radius: 8px; font-size: 0.7rem;
      cursor: pointer; transition: background 0.2s ease;
    }
    .accepted-chapter-actions button:hover { background: #2a2a2e; }
    .accepted-chapter-actions .danger { border-color: #e26a6a; color: #ffb6b6; }

    /* Bloki reasoning */
    .file-block.reasoning .file-block-header {
      background: rgba(214,179,118,0.12);
    }
    .file-block.reasoning .file-name {
      color: #fef3c7;
    }
    .reasoning-title {
      font-size: 0.72rem; letter-spacing: 0.08em; text-transform: uppercase;
      color: #fef3c7; margin: 14px 2px 6px 2px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div class="chat-container">
    <div class="chat-header">
      <div class="header-info"><h2 id="chat-title">Enigma E‚ÄëBook Builder</h2></div>
      <div class="header-menu">
        <i class="fa-solid fa-ellipsis" id="menu-icon"></i>
        <div class="menu-dropdown" id="menu-dropdown">
          <a href="#" id="new-chat-btn">Nowy czat</a>
          <a href="#" id="end-chat-btn">Zako≈Ñcz czat</a>
          <a href="#" id="history-btn">Historia czat√≥w</a>
        </div>
      </div>
    </div>

    <div id="chapter-management" class="chapter-management">
      <div class="chapter-management-header">
        <h3>Zaakceptowane rozdzia≈Çy</h3>
        <span>ZarzƒÖdzaj zapisanymi tre≈õciami lub popro≈õ o ich poprawƒô.</span>
      </div>
      <ul id="accepted-chapters-list"></ul>
    </div>

    <div id="chat-messages" class="chat-messages"></div>

    <div class="chat-input-container">
      <div class="chat-input-wrapper">
        <textarea id="user-input" placeholder="Napisz wiadomo≈õƒá..." rows="1"></textarea>
        <button id="send-btn"><i class="fa-solid fa-paper-plane"></i></button>
      </div>
    </div>
  </div>

  <!-- History Modal -->
  <div class="history-modal" id="history-modal">
    <div class="history-content">
      <div class="history-header">
        <h3>Historia Czat√≥w</h3>
        <button id="close-history">&times;</button>
      </div>
      <ul id="history-list"></ul>
    </div>
  </div>

  <script>
    /* =========================
       KONFIG & STAN SESJI
    ==========================*/
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.worker.min.js';
    }

    const chatMessages = document.getElementById('chat-messages');
    const userInput    = document.getElementById('user-input');
    const sendBtn      = document.getElementById('send-btn');

    const menuIcon     = document.getElementById('menu-icon');
    const menuDropdown = document.getElementById('menu-dropdown');
    const newChatBtn   = document.getElementById('new-chat-btn');
    const endChatBtn   = document.getElementById('end-chat-btn');
    const historyBtn   = document.getElementById('history-btn');
    const historyModal = document.getElementById('history-modal');
    const closeHistoryBtn = document.getElementById('close-history');
    const historyList  = document.getElementById('history-list');
    const chapterManagement = document.getElementById('chapter-management');
    const acceptedChaptersList = document.getElementById('accepted-chapters-list');

    let currentChatId = null;

    function generateSessionId() {
      return `ebook_${Math.random().toString(36).slice(2,8)}_${Date.now()}`;
    }

    // Unikalny identyfikator sesji do zapisu plik√≥w na serwerze
    const ebookState = {
      sessionId: generateSessionId(),
      stage: 'intro',           // intro -> meta -> toc -> chapters -> final
      currentChapter: 0,
      totalChapters: null,
      lastGenerated: null,      // { type: 'chapter', filename, content, chapterIndex }
      accepted: [],             // [{filename, chapterIndex}]
      tocContent: '',
      tocEntries: [],
      reasoningSummaries: {},   // { [chapterIndex]: summary }
      lastReasoningGenerated: null
    };

    const knowledgeBase = {
      url: 'knowledge_base/Analiza_rynku_Ebook_Copywriting.pdf',
      status: 'idle',
      loadPromise: null,
      text: '',
      excerpt: '',
      lastError: null,
      notified: false
    };

    // Pe≈Çny kontekst rozmowy (dla API)
    const conversationContext = {
      fullHistory: [],
      coreInstructions:
`# **üî• AI COPYWRITING MASTER üî•**
Jeste≈õ asystentem budujƒÖcym eBooki (100+ stron ‚Äì je≈õli temat wymaga).
Zasady KRYTYCZNE:
‚Ä¢ Nigdy nie wypisuj pe≈Çnych rozdzia≈Ç√≥w w czacie. Zamiast tego zawsze zwracaj tre≈õƒá jako blok pliku.
‚Ä¢ Format pliku: <FILE name="NAZWA.txt">...tre≈õƒá...</FILE>
‚Ä¢ Poza blokami pliku podawaj TYLKO kr√≥tki status (2‚Äì5 zda≈Ñ) i kolejnƒÖ akcjƒô (np. ‚ÄûAkceptuj / Popraw / Dalej‚Äù).
‚Ä¢ Zachowuj pe≈Çny kontekst ca≈Çego eBooka miƒôdzy rozdzia≈Çami i korzystaj z przekazywanych podsumowa≈Ñ reasoning.

Proces:
1) Zbierz: temat, grupa docelowa, styl, oczekiwana d≈Çugo≈õƒá (liczba rozdzia≈Ç√≥w i ~d≈Çugo≈õƒá rozdzia≈Çu).
2) Gdy wszystko masz ‚Äì wygeneruj **spis tre≈õci** jako plik:
   <FILE name="spis_tresci.txt">
   [lista numerowana rozdzia≈Ç√≥w z tytu≈Çami]
   __CHAPTERS_COUNT__=N
   </FILE>
   W czacie daj kr√≥tki opis + popro≈õ o akceptacjƒô spisu.
3) Po akceptacji spisu generuj ROZDZIA≈ÅY po kolei (ok. ~800 s≈Ç√≥w ka≈ºdy) tak:
   <FILE name="rozdzial_01.txt">‚Ä¶Tre≈õƒá rozdzia≈Çu 1‚Ä¶</FILE>
4) Po ka≈ºdym rozdziale czekaj na decyzjƒô: Akceptuj / Popraw (z instrukcjami).
   ‚Ä¢ Przy ‚ÄûPopraw‚Äù: wygeneruj ponownie TYLKO rozdzia≈Ç N (jak wy≈ºej).
5) Po zaakceptowaniu wszystkich ‚Äì nie wypisuj tre≈õci w czacie:
   backend scali rozdzia≈Çy do ebook_final.txt.

Dodatkowe wymogi reasoning:
‚Ä¢ Ka≈ºdy rozdzia≈Ç musi zostaƒá wygenerowany RAZEM z plikiem reasoning_NN.txt.
‚Ä¢ Plik reasoning_NN.txt zawiera sekcje: ‚ÄûKoncepcja eBooka‚Äù, ‚ÄûStreszczenie bie≈ºƒÖcego rozdzia≈Çu‚Äù, ‚ÄûPowiƒÖzanie z poprzednim rozdzia≈Çem‚Äù, ‚ÄûZapowied≈∫ kolejnego rozdzia≈Çu (wg spisu tre≈õci)‚Äù.
‚Ä¢ Tre≈õƒá rozdzia≈Çu w pliku rozdzia≈Ç_NN.txt to wy≈ÇƒÖcznie finalny materia≈Ç eBooka (bez meta-komentarzy).

Wszystko po polsku. Trzymaj jako≈õƒá merytorycznƒÖ i sp√≥jno≈õƒá miƒôdzy rozdzia≈Çami.`
    };

    function splitParagraphs(text) {
      return (text || '')
        .split(/\n{2,}/)
        .map(p => p.replace(/\s+/g, ' ').trim())
        .filter(Boolean);
    }

    function buildExcerptFromParagraphs(paragraphs, maxChars = 3600) {
      const selected = [];
      let total = 0;
      for (const p of paragraphs) {
        if (!p) continue;
        selected.push(p);
        total += p.length + 2;
        if (total >= maxChars) break;
      }
      return selected.join('\n\n').slice(0, maxChars);
    }

    function deriveKnowledgeQuery({ userText = '', explicitQuery = '' }) {
      if (explicitQuery) return explicitQuery;
      const lower = userText.toLowerCase();
      if (ebookState.stage === 'chapters') {
        const idx = ebookState.currentChapter || ebookState.lastGenerated?.chapterIndex || 1;
        const entry = getTocEntry(idx);
        if (entry) {
          return `${entry.title} ${entry.description || ''}`.trim();
        }
      }
      if (ebookState.stage === 'toc' || lower.includes('spis tre≈õci')) {
        return 'spis tre≈õci ebook marketing copywriting';
      }
      if (lower.includes('tytu≈Ç')) {
        return 'tytu≈Ç ebook marketingowy strategia';
      }
      return 'ebook marketing copywriting analiza rynku automatyzacja lejki';
    }

    function selectKnowledgeSnippets(query, maxChars = 3600) {
      if (!knowledgeBase.text) return '';
      const paragraphs = splitParagraphs(knowledgeBase.text);
      if (!paragraphs.length) return '';

      const terms = Array.from(new Set((query || '')
        .toLowerCase()
        .split(/[^a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º0-9]+/i)
        .filter(token => token && token.length > 3)));

      if (!terms.length) {
        return buildExcerptFromParagraphs(paragraphs, maxChars);
      }

      const scored = paragraphs.map((p, idx) => {
        const lower = p.toLowerCase();
        let score = 0;
        for (const term of terms) {
          if (lower.includes(term)) score += 2;
          if (lower.startsWith(term)) score += 1;
        }
        return { p, score, idx };
      });

      scored.sort((a, b) => {
        if (b.score === a.score) return a.idx - b.idx;
        return b.score - a.score;
      });

      const selected = [];
      let total = 0;
      for (const item of scored) {
        if (!item.p) continue;
        if (item.score <= 0 && selected.length) break;
        selected.push(item.p);
        total += item.p.length + 2;
        if (total >= maxChars) break;
      }

      if (!selected.length) {
        return buildExcerptFromParagraphs(paragraphs, maxChars);
      }

      const snippet = selected.join('\n\n');
      return snippet.length > maxChars ? snippet.slice(0, maxChars) : snippet;
    }

    function buildKnowledgeMessage({ query, stage }) {
      if (!knowledgeBase.text) return '';
      const snippet = selectKnowledgeSnippets(query, 3400);
      if (!snippet) return '';
      const stageHint = stage === 'chapters'
        ? 'PrzygotowujƒÖc kolejny rozdzia≈Ç'
        : stage === 'toc'
          ? 'TworzƒÖc spis tre≈õci lub sekcjƒô meta'
          : 'TworzƒÖc zawarto≈õƒá eBooka';

      return `${stageHint} korzystaj z materia≈Çu referencyjnego "Analiza_rynku_Ebook_Copywriting.pdf". Kluczowe fragmenty:\n${snippet}\n\nW≈ÇƒÖcz powy≈ºsze dane do tre≈õci w≈Çasnymi s≈Çowami, zachowujƒÖc sp√≥jno≈õƒá ze spisem tre≈õci i koncepcjƒÖ ebooka.`;
    }

    async function loadKnowledgeBase() {
      if (!window.pdfjsLib) {
        knowledgeBase.status = 'error';
        knowledgeBase.lastError = new Error('Brak biblioteki pdf.js');
        throw knowledgeBase.lastError;
      }
      if (knowledgeBase.status === 'loaded') {
        return knowledgeBase;
      }
      if (knowledgeBase.status === 'loading' && knowledgeBase.loadPromise) {
        await knowledgeBase.loadPromise;
        return knowledgeBase;
      }

      knowledgeBase.status = 'loading';
      knowledgeBase.loadPromise = (async () => {
        const loadingTask = pdfjsLib.getDocument({ url: knowledgeBase.url });
        const pdfDoc = await loadingTask.promise;
        const chunks = [];

        for (let pageNumber = 1; pageNumber <= pdfDoc.numPages; pageNumber += 1) {
          const page = await pdfDoc.getPage(pageNumber);
          const content = await page.getTextContent();
          const pageText = content.items
            .map(item => (item.str || ''))
            .join(' ')
            .replace(/\s+/g, ' ')
            .trim();
          if (pageText) {
            chunks.push(pageText);
          }
        }

        knowledgeBase.text = chunks.join('\n\n');
        knowledgeBase.excerpt = buildExcerptFromParagraphs(splitParagraphs(knowledgeBase.text), 3400);
        knowledgeBase.status = 'loaded';
        knowledgeBase.lastError = null;
      })().catch(err => {
        knowledgeBase.status = 'error';
        knowledgeBase.lastError = err;
        throw err;
      }).finally(() => {
        knowledgeBase.loadPromise = null;
      });

      await knowledgeBase.loadPromise;
      return knowledgeBase;
    }

    function resetEbookState({ newSession = false } = {}) {
      if (newSession) {
        ebookState.sessionId = generateSessionId();
      }
      ebookState.stage = 'intro';
      ebookState.currentChapter = 0;
      ebookState.totalChapters = null;
      ebookState.lastGenerated = null;
      ebookState.accepted = [];
      ebookState.tocContent = '';
      ebookState.tocEntries = [];
      ebookState.reasoningSummaries = {};
      ebookState.lastReasoningGenerated = null;
      renderAcceptedChapters();
    }

    function parseTOCEntries(content) {
      if (!content) return [];
      const lines = content.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const entries = [];
      const re = /^(\d+)[\)\.]?\s*(.*)$/;
      for (const line of lines) {
        if (!re.test(line)) continue;
        const [, numStr, restRaw] = line.match(re);
        const index = parseInt(numStr, 10);
        if (!Number.isFinite(index)) continue;
        let title = restRaw.trim();
        let description = '';
        const dashIdx = title.indexOf(' - ');
        const colonIdx = title.indexOf(': ');
        let splitIdx = -1;
        if (dashIdx !== -1) splitIdx = dashIdx;
        else if (colonIdx !== -1) splitIdx = colonIdx;
        if (splitIdx !== -1) {
          description = title.slice(splitIdx + 3).trim();
          title = title.slice(0, splitIdx).trim();
        }
        entries.push({ index, title, description });
      }
      return entries;
    }

    function getTocEntry(idx) {
      return ebookState.tocEntries.find(e => e.index === idx) || null;
    }

    function buildChapterLabel(idx) {
      const entry = getTocEntry(idx);
      const base = `Rozdzia≈Ç ${String(idx).padStart(2, '0')}`;
      if (!entry) return base;
      const details = entry.description ? `${entry.title} ‚Äî ${entry.description}` : entry.title;
      return `${base}: ${details}`;
    }

    function renderAcceptedChapters() {
      acceptedChaptersList.innerHTML = '';
      const items = [...ebookState.accepted].sort((a, b) => a.chapterIndex - b.chapterIndex);
      if (!items.length) {
        chapterManagement.classList.remove('has-items');
        return;
      }
      chapterManagement.classList.add('has-items');
      for (const item of items) {
        const li = document.createElement('li');
        li.className = 'accepted-chapter-item';

        const label = document.createElement('div');
        label.className = 'accepted-chapter-label';
        label.textContent = buildChapterLabel(item.chapterIndex);

        const actions = document.createElement('div');
        actions.className = 'accepted-chapter-actions';

        const rewriteBtn = document.createElement('button');
        rewriteBtn.textContent = 'üîÅ Nadpisz';
        rewriteBtn.addEventListener('click', () => requestChapterRewriteFlow(item.chapterIndex));

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'üóëÔ∏è Usu≈Ñ';
        deleteBtn.classList.add('danger');
        deleteBtn.addEventListener('click', () => handleChapterDeleteFlow(item.chapterIndex));

        actions.appendChild(rewriteBtn);
        actions.appendChild(deleteBtn);

        li.appendChild(label);
        li.appendChild(actions);

        acceptedChaptersList.appendChild(li);
      }
    }

    async function deleteFileOnServer(filename) {
      const res = await fetch('combine_ebooks.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'delete',
          sessionId: ebookState.sessionId,
          filename
        })
      });
      if (!res.ok) throw new Error(`Delete HTTP ${res.status}`);
      const data = await res.json();
      if (!data.ok) throw new Error(data.error || 'Nieznany b≈ÇƒÖd usuwania');
      return data;
    }

    async function deleteChapterAssets(idx, { silent = false } = {}) {
      const n = String(idx).padStart(2, '0');
      const targets = [`rozdzial_${n}.txt`, `reasoning_${n}.txt`];
      for (const file of targets) {
        try {
          await deleteFileOnServer(file);
        } catch (err) {
          if (!silent) {
            addChatMessage(`‚ùå Nie uda≈Ço siƒô usunƒÖƒá pliku ${file}: ${err.message}`, false);
          }
        }
      }
      ebookState.accepted = ebookState.accepted.filter(item => item.chapterIndex !== idx);
      delete ebookState.reasoningSummaries[idx];
      if (ebookState.lastGenerated?.chapterIndex === idx) {
        ebookState.lastGenerated = null;
      }
      if (ebookState.lastReasoningGenerated?.chapterIndex === idx) {
        ebookState.lastReasoningGenerated = null;
      }
      if (ebookState.currentChapter >= idx) {
        ebookState.currentChapter = idx;
      }
      renderAcceptedChapters();
    }

    async function requestChapterRewriteFlow(idx) {
      const notes = prompt(`Jakie poprawki wprowadziƒá w rozdziale ${idx}?`);
      if (notes === null) return;
      await deleteChapterAssets(idx, { silent: true });
      addChatMessage(`Nadpisujƒô rozdzia≈Ç ${idx}. Generujƒô nowƒÖ wersjƒô na podstawie Twoich wskaz√≥wek‚Ä¶`, false);
      ebookState.stage = 'chapters';
      ebookState.currentChapter = idx;
      await requestChapter(idx, `ZastƒÖp poprzedniƒÖ wersjƒô rozdzia≈Çu ${idx}. Uwzglƒôdnij poprawki u≈ºytkownika: ${notes}`);
    }

    async function handleChapterDeleteFlow(idx) {
      if (!confirm(`Czy na pewno usunƒÖƒá rozdzia≈Ç ${idx}?`)) return;
      await deleteChapterAssets(idx);
      addChatMessage(`Rozdzia≈Ç ${idx} zosta≈Ç usuniƒôty. Mo≈ºesz poprosiƒá o przygotowanie nowej wersji w dowolnym momencie.`, false);
    }

    /* =========================
       UI ‚Äî DROBNE POMOCNICZE
    ==========================*/
    function addChatMessage(html, isUser = false) {
      const div = document.createElement('div');
      div.classList.add('message', isUser ? 'user-message' : 'bot-message');
      div.innerHTML = html;
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return div;
    }

    function showTypingIndicator() {
      const indicator = document.createElement('div');
      indicator.id = 'typing-indicator';
      indicator.className = 'typing-indicator';
      indicator.innerHTML =
        `<div class="typing-indicator-dots">
           <div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>
         </div>`;
      chatMessages.appendChild(indicator);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    function hideTypingIndicator() {
      const el = document.getElementById('typing-indicator');
      if (el) el.remove();
    }

    function saveChat() {
      if (!currentChatId) return;
      const chats = JSON.parse(localStorage.getItem('enigma_chats') || '{}');
      chats[currentChatId] = { timestamp: Date.now(), history: conversationContext.fullHistory };
      localStorage.setItem('enigma_chats', JSON.stringify(chats));
    }

    function startNewChat() {
      currentChatId = `chat_${Date.now()}`;
      conversationContext.fullHistory = [];
      chatMessages.innerHTML = '';
      resetEbookState({ newSession: true });

      if (knowledgeBase.status === 'idle') {
        loadKnowledgeBase().catch(err => console.warn('Knowledge base prefetch failed', err));
      }

      addChatMessage(
        `<strong>Witaj! Tu Enigma E‚ÄëBook Builder.</strong>
        Zacznijmy: podaj proszƒô <em>temat</em> eBooka, docelowƒÖ <em>grupƒô odbiorc√≥w</em> i preferowany <em>styl</em> (np. biznesowy/storytelling/techniczny).<br>
        Potem ustalimy d≈Çugo≈õƒá (liczbƒô rozdzia≈Ç√≥w i ~d≈Çugo≈õƒá rozdzia≈Çu), wygenerujƒô spis tre≈õci do akceptacji, a nastƒôpnie rozdzia≈Çy ‚Äì ka≈ºdy jako <u>plik .txt do podglƒÖdu i pobrania</u>.`);
      userInput.focus();
    }

    function displayChatHistory() {
      const chats = JSON.parse(localStorage.getItem('enigma_chats') || '{}');
      const thirtyDaysAgo = Date.now() - 30*24*60*60*1000;
      const recent = Object.entries(chats).filter(([,c]) => c.timestamp > thirtyDaysAgo);
      recent.sort(([,a],[,b]) => b.timestamp - a.timestamp);

      const historyList = document.getElementById('history-list');
      historyList.innerHTML = '';
      if (!recent.length) {
        historyList.innerHTML = '<li>Brak historii czat√≥w.</li>';
      } else {
        for (const [id, chat] of recent) {
          const firstUser = chat.history.find(m => m.role==='user');
          const preview = firstUser?.content ? (firstUser.content.slice(0,40)+'...') : 'Czat';
          const li = document.createElement('li');
          li.textContent = `${preview} - ${new Date(chat.timestamp).toLocaleString()}`;
          li.addEventListener('click', () => {
            currentChatId = id;
            conversationContext.fullHistory = chat.history;
            renderChatFromHistory();
            historyModal.style.display = 'none';
          });
          historyList.appendChild(li);
        }
      }
      historyModal.style.display = 'flex';
    }

    function renderChatFromHistory() {
      chatMessages.innerHTML = '';
      for (const m of conversationContext.fullHistory) {
        // Je≈õli zapisywali≈õmy gotowy HTML (np. z podglƒÖdami plik√≥w) ‚Äî u≈ºyj go
        const html = (m.role === 'assistant') ? (m.renderedHtml || m.content.replace(/\n/g,'<br>'))
                                              : m.content.replace(/\n/g,'<br>');
        addChatMessage(html, m.role==='user');
      }
    }

    /* =========================
       PODGLƒÑD PLIK√ìW (TXT)
    ==========================*/
    function escapeHtml(s){
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }
    function makePreviewBlock(name, content, opts = {}){
      const id = `pv_${Math.random().toString(36).slice(2,8)}_${Date.now()}`;
      const downloadHtml = opts.downloadHtml || '';
      const variantClass = opts.variant ? ` ${opts.variant}` : '';
      const iconHtml = opts.iconHtml || '<i class="fa-regular fa-file-lines" style="color:#d6b376;"></i>';
      return `
        <div class="file-block${variantClass}" data-pv-id="${id}">
          <div class="file-block-header">
            <div class="file-name">${iconHtml}${escapeHtml(name)}</div>
            <div class="file-actions">
              <button class="btn-toggle-preview" data-pv-target="${id}">PodglƒÖd</button>
              <button class="btn-copy-text" data-pv-target="${id}">Kopiuj</button>
              ${downloadHtml}
            </div>
          </div>
          <div class="file-preview" id="${id}">
            <div class="file-preview-body">${escapeHtml(content)}</div>
          </div>
        </div>`;
    }
    // Delegacja zdarze≈Ñ dla przycisk√≥w ‚ÄûPodglƒÖd/Kopiuj‚Äù
    chatMessages.addEventListener('click', (e)=>{
      const btnPreview = e.target.closest('.btn-toggle-preview');
      const btnCopy = e.target.closest('.btn-copy-text');

      if(btnPreview){
        const id = btnPreview.dataset.pvTarget;
        const pane = document.getElementById(id);
        if (!pane) return;
        const open = pane.style.display === 'block';
        pane.style.display = open ? 'none' : 'block';
        btnPreview.textContent = open ? 'PodglƒÖd' : 'Ukryj';
      }

      if(btnCopy){
        const id = btnCopy.dataset.pvTarget;
        const pane = document.getElementById(id);
        const body = pane?.querySelector('.file-preview-body');
        if(!body) return;
        const tmp = document.createElement('textarea');
        tmp.value = body.textContent;
        document.body.appendChild(tmp);
        tmp.select();
        document.execCommand('copy');
        document.body.removeChild(tmp);
        btnCopy.textContent = 'Skopiowano';
        setTimeout(()=>btnCopy.textContent='Kopiuj', 1200);
      }
    });

    /* =========================
       PARSOWANIE BLOK√ìW PLIK√ìW
    ==========================*/
    function parseFileBlocks(text) {
      const files = [];
      const re = /<FILE\s+name="([^"]+)">\s*([\s\S]*?)<\/FILE>/g;
      let m;
      while ((m = re.exec(text)) !== null) {
        files.push({ name: m[1], content: m[2].trim() });
      }
      return files;
    }
    function makeDownloadLink(name, content) {
      const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
      const url  = URL.createObjectURL(blob);
      return `<a href="${url}" download="${name}" class="primary">Pobierz</a>`;
    }
    function extractChaptersCountFromTOC(tocContent) {
      const m = tocContent.match(/^\s*__CHAPTERS_COUNT__\s*=\s*(\d+)\s*$/m);
      return m ? parseInt(m[1], 10) : null;
    }

    /* =========================
       BACKEND: DEEPSEEK + ZAPIS
    ==========================*/
    async function callDeepSeek(messages, retryCount = 0) {
        const maxRetries = 2;
        
        try {
            const res = await fetch("deepseek_proxy.php", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                    model: "deepseek-chat", 
                    messages,
                    max_tokens: 4000
                })
            });
            
            if (!res.ok) {
                if (res.status === 502 && retryCount < maxRetries) {
                    // Czekaj i pon√≥w przy b≈Çƒôdzie 502
                    await new Promise(resolve => setTimeout(resolve, 2000 * (retryCount + 1)));
                    return callDeepSeek(messages, retryCount + 1);
                }
                throw new Error(`HTTP ${res.status}`);
            }
            
            return res.json();
        } catch (error) {
            if (retryCount < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, 2000 * (retryCount + 1)));
                return callDeepSeek(messages, retryCount + 1);
            }
            throw error;
        }
    }
    
    async function saveFileOnServer(filename, content) {
      const res = await fetch("combine_ebooks.php", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: "save",
          sessionId: ebookState.sessionId,
          filename,
          content
        })
      });
      if (!res.ok) throw new Error(`Save HTTP ${res.status}`);
      return res.json(); // { ok:true, url:"/ebooks/temp/<sessionId>/<filename>" }
    }
    async function combineFinalOnServer() {
      const res = await fetch("combine_ebooks.php", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: "combine",
          sessionId: ebookState.sessionId
        })
      });
      if (!res.ok) throw new Error(`Combine HTTP ${res.status}`);
      return res.json(); // { ok:true, url:"/ebooks/temp/<sessionId>/ebook_final.txt" }
    }

    /* =========================
       G≈Å√ìWNY PRZEP≈ÅYW ROZMOWY
    ==========================*/
    function attachActionBar(parentMessageEl, buttons) {
      const bar = document.createElement('div');
      bar.className = 'action-bar';
      for (const b of buttons) {
        const btn = document.createElement('button');
        btn.className = `action-btn ${b.variant||''}`;
        btn.textContent = b.label;
        btn.addEventListener('click', b.onClick);
        bar.appendChild(btn);
      }
      parentMessageEl.appendChild(bar);
    }

    async function sendToDeepSeekAI(userText, options = {}) {
      showTypingIndicator();

      ebookState.lastReasoningGenerated = null;

      const opts = options || {};
      const lowerUserText = (userText || '').toLowerCase();
      const shouldAttachKnowledge = !!(opts.forceKnowledge
        || opts.knowledgeQuery
        || ebookState.stage === 'chapters'
        || ebookState.stage === 'toc'
        || lowerUserText.includes('spis tre≈õci')
        || lowerUserText.includes('rozdzia≈Ç')
        || lowerUserText.includes('ebook'));

      let knowledgeSystemMessage = '';
      if (shouldAttachKnowledge) {
        try {
          await loadKnowledgeBase();
          if (knowledgeBase.status === 'loaded' && knowledgeBase.text) {
            const query = deriveKnowledgeQuery({
              userText: lowerUserText,
              explicitQuery: opts.knowledgeQuery || ''
            });
            knowledgeSystemMessage = buildKnowledgeMessage({
              query,
              stage: ebookState.stage
            });
          }
        } catch (kbErr) {
          console.error('Knowledge base load failed', kbErr);
          if (!knowledgeBase.notified) {
            addChatMessage('‚ö†Ô∏è Nie uda≈Ço siƒô za≈Çadowaƒá materia≈Çu referencyjnego Analiza_rynku_Ebook_Copywriting.pdf. Kontynuujƒô bez niego.', false);
            knowledgeBase.notified = true;
          }
        }
      }

      // zbuduj pe≈Çne messages dla DeepSeek API
      const apiHistory = conversationContext.fullHistory.map(m => ({ role: m.role, content: m.content }));
      const messages = [
        { role: "system", content: conversationContext.coreInstructions },
        { role: "system", content:
          `KONTROLER:
           ‚Ä¢ sessionId=${ebookState.sessionId}
           ‚Ä¢ stage=${ebookState.stage}
           ‚Ä¢ currentChapter=${ebookState.currentChapter}
           ‚Ä¢ totalChapters=${ebookState.totalChapters ?? 'unknown'}
           ‚Ä¢ PAMIƒòTAJ o formacie <FILE name="...">...</FILE>.`
        },
        ...apiHistory,
        { role: "user", content: userText }
      ];

      if (knowledgeSystemMessage) {
        messages.splice(1, 0, { role: 'system', content: knowledgeSystemMessage });
      }

      try {
        const data = await callDeepSeek(messages);
        const raw = (data.choices?.[0]?.message?.content || '').trim();
        hideTypingIndicator();

        // Zapamiƒôtaj surowƒÖ odpowied≈∫ w historii (dla kontekstu)
        const assistantMsg = { role: 'assistant', content: raw };
        conversationContext.fullHistory.push(assistantMsg);

        // Znajd≈∫ pliki i zbuduj status
        const files = parseFileBlocks(raw);
        let statusText = raw.replace(/<FILE[\s\S]*?<\/FILE>/g, '').trim();
        if (!statusText) statusText = "Gotowe. Wybierz akcjƒô poni≈ºej.";

        // BƒÖbel odpowiedzi
        let html = statusText.replace(/\n/g,'<br>');
        const wrap = addChatMessage(html, false);

        // PodglƒÖdy + szybkie pobrania
        let renderedFilesHtml = '';
        let reasoningBlocksHtml = '';
        for (const f of files) {
          const dl = makeDownloadLink(f.name, f.content);
          if (/^reasoning_\d+\.txt$/i.test(f.name)) {
            const match = f.name.match(/(\d+)/);
            const idx = match ? parseInt(match[1], 10) : null;
            if (idx) {
              ebookState.reasoningSummaries[idx] = f.content;
              ebookState.lastReasoningGenerated = {
                filename: f.name,
                content: f.content,
                chapterIndex: idx
              };
            }
            reasoningBlocksHtml += makePreviewBlock(f.name, f.content, {
              downloadHtml: dl,
              variant: ' reasoning',
              iconHtml: '<i class="fa-solid fa-brain" style="color:#fef08a;"></i>'
            });
            continue;
          }

          renderedFilesHtml += makePreviewBlock(f.name, f.content, { downloadHtml: dl });
        }
        if (renderedFilesHtml) {
          const filesWrap = document.createElement('div');
          filesWrap.innerHTML = renderedFilesHtml;
          wrap.appendChild(filesWrap);
        }
        if (reasoningBlocksHtml) {
          const reasoningWrap = document.createElement('div');
          reasoningWrap.innerHTML = `<div class="reasoning-title">Reasoning / pamiƒôƒá rozdzia≈Çu</div>${reasoningBlocksHtml}`;
          wrap.appendChild(reasoningWrap);
        }

        // zapisz wyrenderowany HTML tej wiadomo≈õci (≈ºeby historia odtworzy≈Ça podglƒÖdy)
        assistantMsg.renderedHtml = wrap.innerHTML;

        // --- Sterowanie etapami ---

        // 1) Spis tre≈õci
        const tocFile = files.find(f => f.name.toLowerCase() === 'spis_tresci.txt');
        if (tocFile) {
          ebookState.stage = 'toc';
          ebookState.currentChapter = 0;
          const cnt = extractChaptersCountFromTOC(tocFile.content);
          if (cnt) ebookState.totalChapters = cnt;
          ebookState.tocContent = tocFile.content;
          ebookState.tocEntries = parseTOCEntries(tocFile.content);

          attachActionBar(wrap, [
            {
              label: "üìò Akceptuj spis",
              variant: "primary",
              onClick: async () => {
                try {
                  await saveFileOnServer('spis_tresci.txt', tocFile.content);
                  addChatMessage("Spis tre≈õci zapisany. Generujƒô rozdzia≈Ç 1‚Ä¶", false);
                  ebookState.stage = 'chapters';
                  ebookState.currentChapter = 1;
                  ebookState.accepted = [];
                  ebookState.reasoningSummaries = {};
                  renderAcceptedChapters();
                  await requestChapter(ebookState.currentChapter, "Rozpocznij rozdzia≈Ç 1 zgodnie ze spisem.");
                } catch (e) {
                  addChatMessage("‚ùå B≈ÇƒÖd zapisu spisu: " + e.message, false);
                }
              }
            },
            {
              label: "‚úèÔ∏è Popraw spis",
              onClick: async () => {
                const notes = prompt("Co poprawiƒá w spisie tre≈õci?");
                if (!notes) return;
                await sendToDeepSeekAI(
                  `Popraw spis tre≈õci wg wskaz√≥wek: ${notes}. Zwr√≥ƒá TYLKO plik <FILE name="spis_tresci.txt">‚Ä¶</FILE> oraz liniƒô __CHAPTERS_COUNT__=N.`,
                  { forceKnowledge: true, knowledgeQuery: 'spis tre≈õci ebook marketingowy' }
                );
              }
            }
          ]);
          saveChat();
          return;
        }

        // 2) Rozdzia≈Ç (BEZ reasoning)
        const chapterFile = files.find(f => /^rozdzial_\d+\.txt$/i.test(f.name));
        if (chapterFile) {
          ebookState.stage = 'chapters';
          const m = chapterFile.name.match(/(\d+)/);
          const thisIdx = m ? parseInt(m[1],10) : ebookState.currentChapter || 1;
          ebookState.lastGenerated = {
            type:'chapter',
            filename:chapterFile.name,
            content:chapterFile.content,
            chapterIndex:thisIdx
          };

          attachActionBar(wrap, [
            { label: "üíæ Zapisz rozdzia≈Ç", variant: "primary", onClick: async () => { await acceptChapterAndMaybeNext(false); } },
            { label: "‚è≠Ô∏è Zapisz i generuj kolejny", onClick: async () => { await acceptChapterAndMaybeNext(true); } },
            {
              label: "‚úèÔ∏è Popraw ten rozdzia≈Ç",
              onClick: async () => {
                const notes = prompt("Co poprawiƒá w tym rozdziale?");
                if (!notes) return;
                await sendToDeepSeekAI(
                  `Popraw rozdzia≈Ç ${thisIdx} wg wskaz√≥wek:
                   ${notes}
                   Zwr√≥ƒá TYLKO pliki <FILE name="rozdzial_${String(thisIdx).padStart(2,'0')}.txt">‚Ä¶</FILE> oraz <FILE name="reasoning_${String(thisIdx).padStart(2,'0')}.txt">‚Ä¶</FILE>.`,
                  { forceKnowledge: true, knowledgeQuery: buildChapterLabel(thisIdx) }
                );
              }
            }
          ]);
          saveChat();
          return;
        }

        // Etap pyta≈Ñ/meta ‚Äî tylko zapis rozmowy
        saveChat();

      } catch (e) {
        hideTypingIndicator();
        addChatMessage("‚ùå B≈ÇƒÖd: " + e.message, false);
      }
    }

    async function requestChapter(idx, extraInstruction = "") {
      const n = String(idx).padStart(2,'0');
      const prevSummary = ebookState.reasoningSummaries[idx - 1] || '';
      const currentEntry = getTocEntry(idx);
      const nextEntry = getTocEntry(idx + 1);
      const entryLabel = currentEntry
        ? `${currentEntry.title}${currentEntry.description ? ' ‚Äî ' + currentEntry.description : ''}`
        : `Rozdzia≈Ç ${idx}`;
      const nextInfo = nextEntry
        ? `Nastƒôpny rozdzia≈Ç wed≈Çug spisu: ${nextEntry.title}${nextEntry.description ? ' ‚Äî ' + nextEntry.description : ''}.`
        : 'To ostatni rozdzia≈Ç w zatwierdzonym spisie tre≈õci.';

      const reminder = prevSummary
        ? `Streszczenie poprzedniego rozdzia≈Çu (do zachowania sp√≥jno≈õci):\n${prevSummary}`
        : 'To pierwszy rozdzia≈Ç ‚Äì nawiƒÖ≈º do koncepcji i spisu tre≈õci.';

      const tocReminder = ebookState.tocContent
        ? `Przypomnienie zatwierdzonego spisu tre≈õci:\n${ebookState.tocContent}`
        : '';

      const instruction = `Przygotuj rozdzia≈Ç ${idx} pod tytu≈Çem "${entryLabel}" (~800 s≈Ç√≥w).\n${tocReminder}\n${reminder}\n${nextInfo}\n${extraInstruction}`.trim();

      const request = `${instruction}\n\nZwr√≥ƒá dok≈Çadnie dwa pliki w tej kolejno≈õci:\n1) <FILE name="rozdzial_${n}.txt">[finalna tre≈õƒá rozdzia≈Çu ‚Äì bez meta-komentarzy]</FILE>\n2) <FILE name="reasoning_${n}.txt">[Sekcje: Koncepcja eBooka; Streszczenie bie≈ºƒÖcego rozdzia≈Çu; PowiƒÖzanie z poprzednim rozdzia≈Çem; Zapowied≈∫ kolejnego rozdzia≈Çu]</FILE>`;

      await sendToDeepSeekAI(request, { forceKnowledge: true, knowledgeQuery: entryLabel });
    }

    async function acceptChapterAndMaybeNext(generateNext) {
      const last = ebookState.lastGenerated;
      if (!last || last.type!=='chapter') return;

      try {
        // zapisz rozdzia≈Ç na serwerze (zaakceptowane) - BEZ reasoning
        await saveFileOnServer(last.filename, last.content);

        if (ebookState.lastReasoningGenerated && ebookState.lastReasoningGenerated.chapterIndex === last.chapterIndex) {
          try {
            await saveFileOnServer(ebookState.lastReasoningGenerated.filename, ebookState.lastReasoningGenerated.content);
          } catch (reasoningErr) {
            addChatMessage(`‚ö†Ô∏è Nie uda≈Ço siƒô zapisaƒá reasoning dla rozdzia≈Çu ${last.chapterIndex}: ${reasoningErr.message}`, false);
          }
        }

        ebookState.accepted.push({ filename: last.filename, chapterIndex: last.chapterIndex });
        renderAcceptedChapters();

        // koniec?
        const total = ebookState.totalChapters;
        const isLast = (total && last.chapterIndex >= total);

        if (isLast) {
          addChatMessage("Wszystkie rozdzia≈Çy zaakceptowane. Scalanie w jeden plik‚Ä¶", false);
          const r = await combineFinalOnServer();
          if (r?.ok && r?.url) {
            // TYLKO link do pobrania finalnego ebooka - BEZ podglƒÖdu
            const finalHtml = `
              <div class="final-download">
                <strong>üéâ Ebook gotowy!</strong><br>
                <a href="${r.url}" download="ebook_final.txt">üìò Pobierz gotowego ebooka</a>
              </div>`;
            addChatMessage(finalHtml, false);
            
            // zapisz w historii
            conversationContext.fullHistory.push({ 
              role:'assistant', 
              content:'[final ebook download]', 
              renderedHtml: finalHtml 
            });
            saveChat();
          } else {
            addChatMessage("‚ùå Scalanie nie powiod≈Ço siƒô.", false);
          }
          ebookState.stage = 'final';
          return;
        }

        // Generuj kolejny rozdzia≈Ç?
        if (generateNext) {
          ebookState.currentChapter = last.chapterIndex + 1;
          addChatMessage(`Akceptujƒô. Generujƒô rozdzia≈Ç ${ebookState.currentChapter}‚Ä¶`, false);
          await requestChapter(ebookState.currentChapter);
        } else {
          addChatMessage("Rozdzia≈Ç zapisany. U≈ºyj panelu ‚ÄûZaakceptowane rozdzia≈Çy‚Äù, aby poprosiƒá o nadpisanie lub usuniƒôcie tre≈õci.", false);
          ebookState.currentChapter = last.chapterIndex;
        }
      } catch (e) {
        addChatMessage("‚ùå B≈ÇƒÖd zapisu rozdzia≈Çu: " + e.message, false);
      }
    }

    /* =========================
       OBS≈ÅUGA UI
    ==========================*/
    async function handleSendMessage() {
      const message = userInput.value.trim();
      if (!message) return;
      addChatMessage(message, true);
      conversationContext.fullHistory.push({ role:'user', content: message });
      userInput.value=''; userInput.style.height='auto';
      await sendToDeepSeekAI(message);
      userInput.focus();
    }

    // menu
    const menuIconEl = document.getElementById('menu-icon');
    const menuDropdownEl = document.getElementById('menu-dropdown');
    const historyBtnEl = document.getElementById('history-btn');
    const newChatBtnEl = document.getElementById('new-chat-btn');
    const endChatBtnEl = document.getElementById('end-chat-btn');
    const closeHistoryBtnEl = document.getElementById('close-history');

    menuIconEl.addEventListener('click', () => {
      menuDropdownEl.style.display = (menuDropdownEl.style.display==='block' ? 'none':'block');
    });
    document.addEventListener('click', (e) => {
      if (!menuIconEl.contains(e.target) && !menuDropdownEl.contains(e.target)) menuDropdownEl.style.display='none';
    });

    newChatBtnEl.addEventListener('click', (e) => { e.preventDefault(); startNewChat(); menuDropdownEl.style.display='none'; });
    endChatBtnEl.addEventListener('click', (e) => { e.preventDefault(); startNewChat(); menuDropdownEl.style.display='none'; });
    historyBtnEl.addEventListener('click', (e) => { e.preventDefault(); displayChatHistory(); menuDropdownEl.style.display='none'; });
    closeHistoryBtnEl.addEventListener('click', () => { historyModal.style.display='none'; });

    sendBtn.addEventListener('click', handleSendMessage);
    userInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); }
    });
    userInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = (this.scrollHeight) + 'px';
    });

    document.addEventListener('DOMContentLoaded', () => {
      startNewChat();
      sendBtn.disabled = false;
    });
  </script>
</body>
</html>